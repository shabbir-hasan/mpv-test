https://iamscum.wordpress.com/guides/videoplayback-guide/mpv-conf/
######################################################

For a more detailed documentation click HERE. I only offer a tl;dr version.

If you want to take a look at my mpv.conf, you can view it HERE (don’t copy and paste it!).

Last tested (and recommended) build: mpv-x86_64-20180421-git-65f0825

Stuff you need for some options:

SuperXBR / ravu / nnedi3 [don’t use the files inside “compute” or “gather”]
ravu (use with “gpu-api=vulkan”) [don’t use the files inside “compute” or “gather”]
FSRCNNX
SSimDownscaler / KrigBilateral
Static Noise Luma
Static Noise Chroma
Copy the .hook or .glsl files into the „Shaders“ folder inside the mpv folder (create it, if it doesn’t exist)

Auto-Profiles
Autoload
Easycrop
webm
Copy the .lua files into the „Scripts“ folder inside the mpv folder (create it, if it doesn’t exist).

General:
#The default profile you use for your stuff. Always use this one
profile=gpu-hq

#The called API. Vulkan is highly recommended. 
#Use "opengl" if you have compatibility problems
gpu-api=vulkan

#The backend with the API. Leave it "auto"
#Or use "winvk" with "gpu-api=vulkan" or "win" / "angle" with "gpu-api=opengl"
gpu-context=auto

#Choose the compiler for translating glsl code for Vulkan. Leave it "auto"
#Or use "shaderc" with a nVidia/AMD/Intel GPU or "nvidia" with a nVidia GPU
spirv-compiler=auto

#Decoding API for 8bit h264 (or whatever your CPU supports) content
#Only should be used when you get many frame drops
hwdec=dxva2-copy
Tweaks:
#Cursor hide in ms
cursor-autohide=1000

#Don't close the player after finishing the video
keep-open=yes
Priority:
#Audio language
alang=ja,jp,jpn,en,eng,de,deu,ger

#Subtitle language
slang=en,eng,de,deu,ger
Subs:
#Forces showing subtitles while seeking through the video
demuxer-mkv-subtitle-preroll=yes

#Backward compatibility for vsfilter fansubs
sub-ass-vsfilter-blur-compat=yes

#Fixing the timing for overlaps/gaps when the difference is smaller than 210ms
sub-fix-timing=yes
Volume:
#Default volume when starting the player
volume=100

#Max volume of the player
volume-max=200
Screenshot:
#Output format
screenshot-format=png

#Same output bitdepth as the video
#Set it "=no" if you want to save disc space
screenshot-high-bit-depth=yes

#Compression of the picture (0-10)
#Higher value means better compression
#Set it "1" if you want to take screenshots while playback
screenshot-png-compression=10

#Output directory
screenshot-directory="C:\Users\<your_name>\Desktop"
You make screenshots with the “s” hotkey.

Dither:
#Activate dither (value depends on your screen bitdepth)
#Can lead to ugly outputs, just leave it "auto"
dither-depth=8
Deband & Dynamic Grain:
For an explanation what debanding is, click HERE.
For an explanation what grain is, click HERE.

#Activate deband
#Set it "no" if you rather handle it with profiles
deband=yes

#Deband steps (More = Better quality, but higher GPU cost)
deband-iterations=4

#Deband strength (More = Less banding, but more detail loss)
deband-threshold=50

#Deband range (More = Less banding, but higher GPU cost)
deband-range=16

#Dynamic Grain (More = More dynamic grain)
deband-grain=0
You activate debanding with the “h” hotkey.

You can also set it up automatically for some sources (for example with “HorribleSubs”):

[horriblesubs]
profile-desc=cond:string.match(p.filename, "HorribleSubs")~=nil
deband=yes

[horriblesubs-revert]
profile-desc=cond:string.match(p.filename, "HorribleSubs")==nil
deband=no
(Static) Grain:
For an explanation what static grain is, click HERE.

#Luma
glsl-shader="C:\mpv\Shaders\noise_static_luma.hook"

#Chroma
glsl-shader="C:\mpv\Shaders\noise_static_chroma.hook"
If you use shaders like “nnedi3” or “ravu”, make sure you run this shader before them!

Resizer:
For an explanation what a resizer is, click HERE.
With the “i” hotkey you can see how many delayed and dropped frames you have.

Normal: Regular scaler
Italic: Irregular scaler: Look at (4*) for sinc (with blackman)
Italic & Underlined: Based on a shader: Look at (1*) for FSRCNNX/ravu/nnedi3, look at (2*) for SSimDownscaler, look at (3*) for KrigBilateral

PRESETS		LUMA UPSCALE	LUMA DOWNSCALE		CHROMAUP- & DOWNSCALE
Overkill	FSRCNNX			SSimDownscaler		KrigBilateral
Very High	ravu			ewa_lanczos			ravu
High		ewa_lanczos		ewa_lanczos			ewa_lanczos
Medium		spline16		spline16			sinc (with blackman)
Low			catmull_rom		catmull_rom			catmull_rom
Very Low	bilinear		bilinear			bilinear


Regular scaler:

#Luma upscale 
scale=... 

#Luma downscale 
dscale=... 

#Chroma up- & downscale
cscale=... 
Luma (scale/dscale) = Brightness (black & white) information
Chroma (cscale) = Colour information
Luma is more visible for the human eye.
A better resizer means higher GPU cost.

 

Irregular scaler:
(4*)

sinc (with blackman):

cscale=sinc
cscale-window=blackman
cscale-radius=3
 

Based on a shader:

#Shaders which override "scale"/"dscale"/"cscale" to a certain point (depending on the shader you use)
glsl-shader= ...
(1*) nnedi3 and ravu are only upscaling the video with a power of 2. For example, if your clip is 1280×720 and your screen 1920×1080, the video gets upscaled to 2560×1440. That means “someone” still needs to downscale it. In that case, the “dscale” you set up.

FSRCNNX:

glsl-shader="C:\mpv\Shaders\FSRCNNX_x2_r1_16-0-2-2.glsl"
scale=ewa_lanczos
nnedi3:
Higher “nns” means more neurons (better quality).
Don’t use “win8x6”, always use “win8x4”.

glsl-shader="C:\mpv\Shaders\nnedi3-nns32-win8x4.hook"
scale=ewa_lanczos
ravu:
Higher “r” means higher radius (better quality).

glsl-shader="C:\mpv\Shaders\ravu-r4.hook"
scale=ewa_lanczos
(without addition)= only luma
-chroma-center = only center chroma
-chroma-left = only left chroma
-yuv = luma and chroma

(2*)

SSimDownscaler:

glsl-shader="C:\mpv\Shaders\SSimDownscaler.glsl"
dscale=mitchell
(3*)

KrigBilateral:

glsl-shader="C:\mpv\Shaders\KrigBilateral.glsl"
cscale=mitchell
Anti-Ringing:
For an explanation what anti-ringing is, click HERE.

#Luma upscale deringing (Higher = Less rining, but more detail loss)
scale-antiring=0.7

#Luma downscale deringing (Higher = Less rining, but more detail loss)
dscale-antiring=0.7

#Chroma upscale deringing (Higher = Less rining, but more detail loss)
cscale-antiring=0.7
Interpolation:
For an explanation what interpolation is, click HERE.

#Subtitle blending in scenechanges (smoother effect)
blend-subtitles=yes

#Set the fps as the max. of your monitor Hz
video-sync=display-resample

#Activate interpolation
interpolation=yes

#Interpolation method [look at the table above]
tscale=...
If you have playback issues, deactivate interpolation.

Smoothness/Sharpness	Interpolation
Sharpest				oversample
Sharper					linear
Sharp					catmull_rom
Smooth					mitchell
Smoother				gaussian
Smoothest				bicubic

Deinterlace:
For an explanation what deinterlace is, click HERE.

#Autodetect if deinterlace is needed
deinterlace=auto
You activate deinterlace with the “g” hotkey (“d” if you don’t use my input.conf).
Only use it with interlaced sources (like MPEG2/h264 .ts files)


FSRCNN extended with residual learning (local and global) and recursive blocks with pre-activation structure.
Trained with --distort=True (means it can remove / reduce compression artifacts)
Requires --fbo-format=rgba16hf (rgba16f for opengl)
For example if you placed this shader in the same folder as your mpv.conf, then your config should look like this:

profile=gpu-hq
fbo-format=rgba16hf
glsl-shaders="~~/FSRCNNX_x2_16-0-4-1.glsl"
If you don't know which version to choose - just use FSRCNNX_x2_16-0-4-1 (FSRCNNX_x2_56-16-4-1 would be the optimal option, but it's too slow without MRT support in mpv), or its SSIM version which is sharper.


GPU renderer options
The following video options are currently all specific to --vo=gpu and  --vo=opengl-cb only, which are the only VOs that implement them.

--scale=<filter>
The filter function to use when upscaling video.

bilinear
Bilinear hardware texture filtering (fastest, very low quality). This is the default for compatibility reasons.
spline36
Mid quality and speed. This is the default when using gpu-hq.
lanczos
Lanczos scaling. Provides mid quality and speed. Generally worse than spline36, but it results in a slightly sharper image which is good for some content types. The number of taps can be controlled with  scale-radius, but is best left unchanged.

(This filter is an alias for sinc-windowed sinc)

ewa_lanczos
Elliptic weighted average Lanczos scaling. Also known as Jinc. Relatively slow, but very good quality. The radius can be controlled with scale-radius. Increasing the radius makes the filter sharper but adds more ringing.

(This filter is an alias for jinc-windowed jinc)

ewa_lanczossharp
A slightly sharpened version of ewa_lanczos, preconfigured to use an ideal radius and parameter. If your hardware can run it, this is probably what you should use by default.
mitchell
Mitchell-Netravali. The B and C parameters can be set with  --scale-param1 and --scale-param2. This filter is very good at downscaling (see --dscale).
oversample
A version of nearest neighbour that (naively) oversamples pixels, so that pixels overlapping edges get linearly interpolated instead of rounded. This essentially removes the small imperfections and judder artifacts caused by nearest-neighbour interpolation, in exchange for adding some blur. This filter is good at temporal interpolation, and also known as "smoothmotion" (see --tscale).
linear
A --tscale filter.
There are some more filters, but most are not as useful. For a complete list, pass help as value, e.g.:

mpv --scale=help
--cscale=<filter>
As --scale, but for interpolating chroma information. If the image is not subsampled, this option is ignored entirely.
--dscale=<filter>
Like --scale, but apply these filters on downscaling instead. If this option is unset, the filter implied by --scale will be applied.
--tscale=<filter>
The filter used for interpolating the temporal axis (frames). This is only used if --interpolation is enabled. The only valid choices for  --tscale are separable convolution filters (use --tscale=help to get a list). The default is mitchell.

Common --tscale choices include oversample, linear, catmull_rom, mitchell, gaussian, or bicubic. These are listed in increasing order of smoothness/blurriness, with bicubic being the smoothest/blurriest and oversample being the sharpest/least smooth.

--scale-param1=<value>, --scale-param2=<value>, --cscale-param1=<value>,  --cscale-param2=<value>, --dscale-param1=<value>, --dscale-param2=<value>,  --tscale-param1=<value>, --tscale-param2=<value>
Set filter parameters. Ignored if the filter is not tunable. Currently, this affects the following filter parameters:

bcspline
Spline parameters (B and C). Defaults to 0.5 for both.
gaussian
Scale parameter (t). Increasing this makes the result blurrier. Defaults to 1.
oversample
Minimum distance to an edge before interpolation is used. Setting this to 0 will always interpolate edges, whereas setting it to 0.5 will never interpolate, thus behaving as if the regular nearest neighbour algorithm was used. Defaults to 0.0.
--scale-blur=<value>, --scale-wblur=<value>, --cscale-blur=<value>,  --cscale-wblur=<value>, --dscale-blur=<value>, --dscale-wblur=<value>,  --tscale-blur=<value>, --tscale-wblur=<value>
Kernel/window scaling factor (also known as a blur factor). Decreasing this makes the result sharper, increasing it makes it blurrier (default 0). If set to 0, the kernel's preferred blur factor is used. Note that setting this too low (eg. 0.5) leads to bad results. It's generally recommended to stick to values between 0.8 and 1.2.
--scale-clamp=<0.0-1.0>, --cscale-clamp, --dscale-clamp, --tscale-clamp
Specifies a weight bias to multiply into negative coefficients. Specifying  --scale-clamp=1 has the effect of removing negative weights completely, thus effectively clamping the value range to [0-1]. Values between 0.0 and 1.0 can be specified to apply only a moderate diminishment of negative weights. This is especially useful for --tscale, where it reduces excessive ringing artifacts in the temporal domain (which typically manifest themselves as short flashes or fringes of black, mostly around moving edges) in exchange for potentially adding more blur. The default for  --tscale-clamp is 1.0, the others default to 0.0.
--scale-cutoff=<value>, --cscale-cutoff=<value>, --dscale-cutoff=<value>
Cut off the filter kernel prematurely once the value range drops below this threshold. Doing so allows more aggressive pruning of skippable coefficients by disregarding parts of the LUT which are effectively zeroed out by the window function. Only affects polar (EWA) filters. The default is 0.001 for each, which is perceptually transparent but provides a 10%-20% speedup, depending on the exact radius and filter kernel chosen.
--scale-taper=<value>, --scale-wtaper=<value>, --dscale-taper=<value>,  --dscale-wtaper=<value>, --cscale-taper=<value>, --cscale-wtaper=<value>,  --tscale-taper=<value>, --tscale-wtaper=<value>
Kernel/window taper factor. Increasing this flattens the filter function. Value range is 0 to 1. A value of 0 (the default) means no flattening, a value of 1 makes the filter completely flat (equivalent to a box function). Values in between mean that some portion will be flat and the actual filter function will be squeezed into the space in between.
--scale-radius=<value>, --cscale-radius=<value>, --dscale-radius=<value>,  --tscale-radius=<value>
Set radius for tunable filters, must be a float number between 0.5 and 16.0. Defaults to the filter's preferred radius if not specified. Doesn't work for every scaler and VO combination.

Note that depending on filter implementation details and video scaling ratio, the radius that actually being used might be different (most likely being increased a bit).

--scale-antiring=<value>, --cscale-antiring=<value>, --dscale-antiring=<value>,  --tscale-antiring=<value>
Set the antiringing strength. This tries to eliminate ringing, but can introduce other artifacts in the process. Must be a float number between 0.0 and 1.0. The default value of 0.0 disables antiringing entirely.

Note that this doesn't affect the special filters bilinear and bicubic_fast, nor does it affect any polar (EWA) scalers.

--scale-window=<window>, --cscale-window=<window>, --dscale-window=<window>,  --tscale-window=<window>
(Advanced users only) Choose a custom windowing function for the kernel. Defaults to the filter's preferred window if unset. Use  --scale-window=help to get a list of supported windowing functions.
--scale-wparam=<window>, --cscale-wparam=<window>, --cscale-wparam=<window>,  --tscale-wparam=<window>
(Advanced users only) Configure the parameter for the window function given by --scale-window etc. Ignored if the window is not tunable. Currently, this affects the following window parameters:

kaiser
Window parameter (alpha). Defaults to 6.33.
blackman
Window parameter (alpha). Defaults to 0.16.
gaussian
Scale parameter (t). Increasing this makes the window wider. Defaults to 1.
--scaler-lut-size=<4..10>
Set the size of the lookup texture for scaler kernels (default: 6). The actual size of the texture is 2^N for an option value of N. So the lookup texture with the default setting uses 64 samples.

All weights are linearly interpolated from those samples, so increasing the size of lookup table might improve the accuracy of scaler.

--scaler-resizes-only
Disable the scaler if the video image is not resized. In that case, bilinear is used instead of whatever is set with --scale. Bilinear will reproduce the source image perfectly if no scaling is performed. Enabled by default. Note that this option never affects --cscale.
--linear-scaling
Scale in linear light. It should only be used with a  --fbo-format that has at least 16 bit precision. This option has no effect on HDR content.
--correct-downscaling
When using convolution based filters, extend the filter size when downscaling. Increases quality, but reduces performance while downscaling.

This will perform slightly sub-optimally for anamorphic video (but still better than without it) since it will extend the size to match only the milder of the scale factors between the axes.

--interpolation
Reduce stuttering caused by mismatches in the video fps and display refresh rate (also known as judder).

Warning

This requires setting the --video-sync option to one of the display- modes, or it will be silently disabled. This was not required before mpv 0.14.0.

This essentially attempts to interpolate the missing frames by convoluting the video along the temporal axis. The filter used can be controlled using the --tscale setting.

--interpolation-threshold=<0..1,-1>
Threshold below which frame ratio interpolation gets disabled (default: 0.0001). This is calculated as abs(disphz/vfps - 1) < threshold, where vfps is the speed-adjusted video FPS, and disphz the display refresh rate. (The speed-adjusted video FPS is roughly equal to the normal video FPS, but with slowdown and speedup applied. This matters if you use --video-sync=display-resample to make video run synchronously to the display FPS, or if you change the speed property.)

The default is intended to almost always enable interpolation if the playback rate is even slightly different from the display refresh rate. But note that if you use e.g. --video-sync=display-vdrop, small deviations in the rate can disable interpolation and introduce a discontinuity every other minute.

Set this to -1 to disable this logic.

--opengl-pbo
Enable use of PBOs. On some drivers this can be faster, especially if the source video size is huge (e.g. so called "4K" video). On other drivers it might be slower or cause latency issues.
--dither-depth=<N|no|auto>
Set dither target depth to N. Default: no.

no
Disable any dithering done by mpv.
auto
Automatic selection. If output bit depth cannot be detected, 8 bits per component are assumed.
8
Dither to 8 bit output.
Note that the depth of the connected video display device cannot be detected. Often, LCD panels will do dithering on their own, which conflicts with this option and leads to ugly output.

--dither-size-fruit=<2-8>
Set the size of the dither matrix (default: 6). The actual size of the matrix is (2^N) x (2^N) for an option value of N, so a value of 6 gives a size of 64x64. The matrix is generated at startup time, and a large matrix can take rather long to compute (seconds).

Used in --dither=fruit mode only.

--dither=<fruit|ordered|no>
Select dithering algorithm (default: fruit). (Normally, the  --dither-depth option controls whether dithering is enabled.)
--temporal-dither
Enable temporal dithering. (Only active if dithering is enabled in general.) This changes between 8 different dithering patterns on each frame by changing the orientation of the tiled dithering matrix. Unfortunately, this can lead to flicker on LCD displays, since these have a high reaction time.
--temporal-dither-period=<1-128>
Determines how often the dithering pattern is updated when  --temporal-dither is in use. 1 (the default) will update on every video frame, 2 on every other frame, etc.
--gpu-debug
Enables GPU debugging. What this means depends on the API type. For OpenGL, it calls glGetError(), and requests a debug context. For Vulkan, it enables validation layers.
--opengl-swapinterval=<n>
Interval in displayed frames between two buffer swaps. 1 is equivalent to enable VSYNC, 0 to disable VSYNC. Defaults to 1 if not specified.

Note that this depends on proper OpenGL vsync support. On some platforms and drivers, this only works reliably when in fullscreen mode. It may also require driver-specific hacks if using multiple monitors, to ensure mpv syncs to the right one. Compositing window managers can also lead to bad results, as can missing or incorrect display FPS information (see  --display-fps).

--vulkan-swap-mode=<mode>
Controls the presentation mode of the vulkan swapchain. This is similar to the  --opengl-swapinterval option.

auto
Use the preferred swapchain mode for the vulkan context. (Default)
fifo
Non-tearing, vsync blocked. Similar to "VSync on".
fifo-relaxed
Tearing, vsync blocked. Late frames will tear instead of stuttering.
mailbox
Non-tearing, not vsync blocked. Similar to "triple buffering".
immediate
Tearing, not vsync blocked. Similar to "VSync off".
--vulkan-queue-count=<1..8>
Controls the number of VkQueues used for rendering (limited by how many your device supports). In theory, using more queues could enable some parallelism between frames (when using a  --swapchain-depth higher than 1), but it can also slow things down on hardware where there's no true parallelism between queues. (Default: 1)
--vulkan-async-transfer
Enables the use of async transfer queues on supported vulkan devices. Using them allows transfer operations like texture uploads and blits to happen concurrently with the actual rendering, thus improving overall throughput and power consumption. Enabled by default, and should be relatively safe.
--vulkan-async-compute
Enables the use of async compute queues on supported vulkan devices. Using this, in theory, allows out-of-order scheduling of compute shaders with graphics shaders, thus enabling the hardware to do more effective work while waiting for pipeline bubbles and memory operations. Not beneficial on all GPUs. It's worth noting that if async compute is enabled, and the device supports more compute queues than graphics queues (bound by the restrictions set by --vulkan-queue-count), mpv will internally try and prefer the use of compute shaders over fragment shaders wherever possible. Not enabled by default, since it seems to cause issues with some drivers.
--d3d11-warp=<yes|no|auto>
Use WARP (Windows Advanced Rasterization Platform) with the D3D11 GPU backend (default: auto). This is a high performance software renderer. By default, it is only used when the system has no hardware adapters that support D3D11. While the extended GPU features will work with WARP, they can be very slow.
--d3d11-feature-level=<12_1|12_0|11_1|11_0|10_1|10_0|9_3|9_2|9_1>
Select a specific feature level when using the D3D11 GPU backend. By default, the highest available feature level is used. This option can be used to select a lower feature level, which is mainly useful for debugging. Most extended GPU features will not work at 9_x feature levels.
--d3d11-flip=<yes|no>
Enable flip-model presentation, which avoids unnecessarily copying the backbuffer by sharing surfaces with the DWM (default: yes). This may cause performance issues with older drivers. If flip-model presentation is not supported (for example, on Windows 7 without the platform update), mpv will automatically fall back to the older bitblt presentation model.
--d3d11-sync-interval=<0..4>
Schedule each frame to be presented for this number of VBlank intervals. (default: 1) Setting to 1 will enable VSync, setting to 0 will disable it.
--d3d11va-zero-copy=<yes|no>
By default, when using hardware decoding with --gpu-api=d3d11, the video image will be copied (GPU-to-GPU) from the decoder surface to a shader resource. Set this option to avoid that copy by sampling directly from the decoder image. This may increase performance and reduce power usage, but can cause the image to be sampled incorrectly on the bottom and right edges due to padding, and may invoke driver bugs, since Direct3D 11 technically does not allow sampling from a decoder surface (though most drivers support it.)

Currently only relevant for --gpu-api=d3d11.

--spirv-compiler=<compiler>
Controls which compiler is used to translate GLSL to SPIR-V. This is (currently) only relevant for  --gpu-api=vulkan. The possible choices are:

auto
Use the first available compiler. (Default)
shaderc
Use libshaderc, which is an API wrapper around glslang. This is generally the most preferred, if available.
nvidia
Use nvidia's built-in compiler. Only works for nvidia GPUs. Can be buggy, but also supports some features glslang does not. Only works with vulkan.
--glsl-shaders=<file-list>
Custom GLSL hooks. These are a flexible way to add custom fragment shaders, which can be injected at almost arbitrary points in the rendering pipeline, and access all previous intermediate textures. Each use of the option will add another file to the internal list of shaders (see List Options).

Warning

The syntax is not stable yet and may change any time.

The general syntax of a user shader looks like this:

//!METADATA ARGS...
//!METADATA ARGS...

vec4 hook() {
   ...
   return something;
}

//!METADATA ARGS...
//!METADATA ARGS...

...
Each section of metadata, along with the non-metadata lines after it, defines a single block. There are currently two types of blocks, HOOKs and TEXTUREs.

A TEXTURE block can set the following options:

TEXTURE <name> (required)
The name of this texture. Hooks can then bind the texture under this name using BIND. This must be the first option of the texture block.
SIZE <width> [<height>] [<depth>] (required)
The dimensions of the texture. The height and depth are optional. The type of texture (1D, 2D or 3D) depends on the number of components specified.
FORMAT <name> (required)
The texture format for the samples. Supported texture formats are listed in debug logging when the gpu VO is initialized (look for Texture formats:). Usually, this follows OpenGL naming conventions. For example, rgb16 provides 3 channels with normalized 16 bit components. One oddity are float formats: for example, rgba16f has 16 bit internal precision, but the texture data is provided as 32 bit floats, and the driver converts the data on texture upload.

Although format names follow a common naming convention, not all of them are available on all hardware, drivers, GL versions, and so on.

FILTER <LINEAR|NEAREST>
The min/magnification filter used when sampling from this texture.
BORDER <CLAMP|REPEAT|MIRROR>
The border wrapping mode used when sampling from this texture.
Following the metadata is a string of bytes in hexadecimal notation that define the raw texture data, corresponding to the format specified by FORMAT, on a single line with no extra whitespace.

A HOOK block can set the following options:

HOOK <name> (required)
The texture which to hook into. May occur multiple times within a metadata block, up to a predetermined limit. See below for a list of hookable textures.
DESC <title>
User-friendly description of the pass. This is the name used when representing this shader in the list of passes for property vo-passes.
BIND <name>
Loads a texture (either coming from mpv or from a TEXTURE block) and makes it available to the pass. When binding textures from mpv, this will also set up macros to facilitate accessing it properly. See below for a list. By default, no textures are bound. The special name HOOKED can be used to refer to the texture that triggered this pass.
SAVE <name>
Gives the name of the texture to save the result of this pass into. By default, this is set to the special name HOOKED which has the effect of overwriting the hooked texture.
WIDTH <szexpr>, HEIGHT <szexpr>
Specifies the size of the resulting texture for this pass. szexpr refers to an expression in RPN (reverse polish notation), using the operators + - * / > < !, floating point literals, and references to sizes of existing texture (such as MAIN.width or CHROMA.height), OUTPUT, or NATIVE_CROPPED (size of an input texture cropped after pan-and-scan, video-align-x/y, video-pan-x/y, etc. and possibly prescaled). By default, these are set to HOOKED.w and HOOKED.h, espectively.
WHEN <szexpr>
Specifies a condition that needs to be true (non-zero) for the shader stage to be evaluated. If it fails, it will silently be omitted. (Note that a shader stage like this which has a dependency on an optional hook point can still cause that hook point to be saved, which has some minor overhead)
OFFSET <ox> <oy>
Indicates a pixel shift (offset) introduced by this pass. These pixel offsets will be accumulated and corrected during the next scaling pass (cscale or scale). The default values are 0 0 which correspond to no shift. Note that offsets are ignored when not overwriting the hooked texture.
COMPONENTS <n>
Specifies how many components of this pass's output are relevant and should be stored in the texture, up to 4 (rgba). By default, this value is equal to the number of components in HOOKED.
COMPUTE <bw> <bh> [<tw> <th>]
Specifies that this shader should be treated as a compute shader, with the block size bw and bh. The compute shader will be dispatched with however many blocks are necessary to completely tile over the output. Within each block, there will bw tw*th threads, forming a single work group. In other words: tw and th specify the work group size, which can be different from the block size. So for example, a compute shader with bw, bh = 32 and tw, th = 8 running on a 500x500 texture would dispatch 16x16 blocks (rounded up), each with 8x8 threads.

Compute shaders in mpv are treated a bit different from fragment shaders. Instead of defining a vec4 hook that produces an output sample, you directly define void hook which writes to a fixed writeonly image unit named out_image (this is bound by mpv) using imageStore. To help translate texture coordinates in the absence of vertices, mpv provides a special function NAME_map(id) to map from the texel space of the output image to the texture coordinates for all bound textures. In particular, NAME_pos is equivalent to NAME_map(gl_GlobalInvocationID), although using this only really makes sense if (tw,th) == (bw,bh).

Each bound mpv texture (via BIND) will make available the following definitions to that shader pass, where NAME is the name of the bound texture:

vec4 NAME_tex(vec2 pos)
The sampling function to use to access the texture at a certain spot (in texture coordinate space, range [0,1]). This takes care of any necessary normalization conversions.
vec4 NAME_texOff(vec2 offset)
Sample the texture at a certain offset in pixels. This works like NAME_tex but additionally takes care of necessary rotations, so that sampling at e.g. vec2(-1,0) is always one pixel to the left.
vec2 NAME_pos
The local texture coordinate of that texture, range [0,1].
vec2 NAME_size
The (rotated) size in pixels of the texture.
mat2 NAME_rot
The rotation matrix associated with this texture. (Rotates pixel space to texture coordinates)
vec2 NAME_pt
The (unrotated) size of a single pixel, range [0,1].
float NAME_mul
The coefficient that needs to be multiplied into the texture contents in order to normalize it to the range [0,1].
sampler NAME_raw
The raw bound texture itself. The use of this should be avoided unless absolutely necessary.
Normally, users should use either NAME_tex or NAME_texOff to read from the texture. For some shaders however , it can be better for performance to do custom sampling from NAME_raw, in which case care needs to be taken to respect NAME_mul and NAME_rot.

In addition to these parameters, the following uniforms are also globally available:

float random
A random number in the range [0-1], different per frame.
int frame
A simple count of frames rendered, increases by one per frame and never resets (regardless of seeks).
vec2 input_size
The size in pixels of the input image (possibly cropped and prescaled).
vec2 target_size
The size in pixels of the visible part of the scaled (and possibly cropped) image.
vec2 tex_offset
Texture offset introduced by user shaders or options like panscan, video-align-x/y, video-pan-x/y.
Internally, vo_gpu may generate any number of the following textures. Whenever a texture is rendered and saved by vo_gpu, all of the passes that have hooked into it will run, in the order they were added by the user. This is a list of the legal hook points:

RGB, LUMA, CHROMA, ALPHA, XYZ (resizable)
Source planes (raw). Which of these fire depends on the image format of the source.
CHROMA_SCALED, ALPHA_SCALED (fixed)
Source planes (upscaled). These only fire on subsampled content.
NATIVE (resizable)
The combined image, in the source colorspace, before conversion to RGB.
MAINPRESUB (resizable)
The image, after conversion to RGB, but before  --blend-subtitles=video is applied.
MAIN (resizable)
The main image, after conversion to RGB but before upscaling.
LINEAR (fixed)
Linear light image, before scaling. This only fires when  --linear-scaling is in effect.
SIGMOID (fixed)
Sigmoidized light, before scaling. This only fires when  --sigmoid-upscaling is in effect.
PREKERNEL (fixed)
The image immediately before the scaler kernel runs.
POSTKERNEL (fixed)
The image immediately after the scaler kernel runs.
SCALED (fixed)
The final upscaled image, before color management.
OUTPUT (fixed)
The final output image, after color management but before dithering and drawing to screen.
Only the textures labelled with resizable may be transformed by the pass. When overwriting a texture marked fixed, the WIDTH, HEIGHT and OFFSET must be left at their default values.

--glsl-shader=<file>
CLI/config file only alias for --glsl-shaders-append.
--deband
Enable the debanding algorithm. This greatly reduces the amount of visible banding, blocking and other quantization artifacts, at the expense of very slightly blurring some of the finest details. In practice, it's virtually always an improvement - the only reason to disable it would be for performance.
--deband-iterations=<1..16>
The number of debanding steps to perform per sample. Each step reduces a bit more banding, but takes time to compute. Note that the strength of each step falls off very quickly, so high numbers (>4) are practically useless. (Default 1)
--deband-threshold=<0..4096>
The debanding filter's cut-off threshold. Higher numbers increase the debanding strength dramatically but progressively diminish image details. (Default 64)
--deband-range=<1..64>
The debanding filter's initial radius. The radius increases linearly for each iteration. A higher radius will find more gradients, but a lower radius will smooth more aggressively. (Default 16)

If you increase the --deband-iterations, you should probably decrease this to compensate.

--deband-grain=<0..4096>
Add some extra noise to the image. This significantly helps cover up remaining quantization artifacts. Higher numbers add more noise. (Default 48)
--sigmoid-upscaling
When upscaling, use a sigmoidal color transform to avoid emphasizing ringing artifacts. This also implies --linear-scaling.
--sigmoid-center
The center of the sigmoid curve used for --sigmoid-upscaling, must be a float between 0.0 and 1.0. Defaults to 0.75 if not specified.
--sigmoid-slope
The slope of the sigmoid curve used for --sigmoid-upscaling, must be a float between 1.0 and 20.0. Defaults to 6.5 if not specified.
--sharpen=<value>
If set to a value other than 0, enable an unsharp masking filter. Positive values will sharpen the image (but add more ringing and aliasing). Negative values will blur the image. If your GPU is powerful enough, consider alternatives like the ewa_lanczossharp scale filter, or the  --scale-blur option.
--opengl-glfinish
Call glFinish() before swapping buffers (default: disabled). Slower, but might improve results when doing framedropping. Can completely ruin performance. The details depend entirely on the OpenGL driver.
--opengl-waitvsync
Call glXWaitVideoSyncSGI after each buffer swap (default: disabled). This may or may not help with video timing accuracy and frame drop. It's possible that this makes video output slower, or has no effect at all.

X11/GLX only.

--opengl-dwmflush=<no|windowed|yes|auto>
Calls DwmFlush after swapping buffers on Windows (default: auto). It also sets SwapInterval(0) to ignore the OpenGL timing. Values are: no (disabled), windowed (only in windowed mode), yes (also in full screen).

The value auto will try to determine whether the compositor is active, and calls DwmFlush only if it seems to be.

This may help to get more consistent frame intervals, especially with high-fps clips - which might also reduce dropped frames. Typically, a value of windowed should be enough, since full screen may bypass the DWM.

Windows only.

--angle-d3d11-feature-level=<11_0|10_1|10_0|9_3>
Selects a specific feature level when using the ANGLE backend with D3D11. By default, the highest available feature level is used. This option can be used to select a lower feature level, which is mainly useful for debugging. Note that OpenGL ES 3.0 is only supported at feature level 10_1 or higher. Most extended OpenGL features will not work at lower feature levels (similar to --gpu-dumb-mode).

Windows with ANGLE only.

--angle-d3d11-warp=<yes|no|auto>
Use WARP (Windows Advanced Rasterization Platform) when using the ANGLE backend with D3D11 (default: auto). This is a high performance software renderer. By default, it is used when the Direct3D hardware does not support Direct3D 11 feature level 9_3. While the extended OpenGL features will work with WARP, they can be very slow.

Windows with ANGLE only.

--angle-egl-windowing=<yes|no|auto>
Use ANGLE's built in EGL windowing functions to create a swap chain (default: auto). If this is set to no and the D3D11 renderer is in use, ANGLE's built in swap chain will not be used and a custom swap chain that is optimized for video rendering will be created instead. If set to auto, a custom swap chain will be used for D3D11 and the built in swap chain will be used for D3D9. This option is mainly for debugging purposes, in case the custom swap chain has poor performance or does not work.

If set to yes, the --angle-max-frame-latency,  --angle-swapchain-length and --angle-flip options will have no effect.

Windows with ANGLE only.

--angle-flip=<yes|no>
Enable flip-model presentation, which avoids unnecessarily copying the backbuffer by sharing surfaces with the DWM (default: yes). This may cause performance issues with older drivers. If flip-model presentation is not supported (for example, on Windows 7 without the platform update), mpv will automatically fall back to the older bitblt presentation model.

If set to no, the --angle-swapchain-length option will have no effect.

Windows with ANGLE only.

--angle-renderer=<d3d9|d3d11|auto>
Forces a specific renderer when using the ANGLE backend (default: auto). In auto mode this will pick D3D11 for systems that support Direct3D 11 feature level 9_3 or higher, and D3D9 otherwise. This option is mainly for debugging purposes. Normally there is no reason to force a specific renderer, though --angle-renderer=d3d9 may give slightly better performance on old hardware. Note that the D3D9 renderer only supports OpenGL ES 2.0, so most extended OpenGL features will not work if this renderer is selected (similar to --gpu-dumb-mode).

Windows with ANGLE only.

--cocoa-force-dedicated-gpu=<yes|no>
Deactivates the automatic graphics switching and forces the dedicated GPU. (default: no)

OS X only.

--macos-title-bar-style=<dark|ultradark|light|mediumlight|auto>
Sets the styling of the title bar (default: dark). OS X and cocoa-cb only

dark:	Dark title bar with vibrancy, a subtle blurring effect that dynamically blends the background (Video) into the title bar.
ultradark:	Darker title bar with vibrancy (like QuickTime Player).
light:	Bright title bar with vibrancy.
mediumlight:	Less bright title bar with vibrancy.
auto:	Detects the system settings and sets the title bar styling appropriately, either ultradark or mediumlight.
--macos-fs-animation-duration=<default|0-1000>
Sets the fullscreen resize animation duration in ms (default: default). The default value is slightly less than the system's animation duration (500ms) to prevent some problems when the end of an async animation happens at the same time as the end of the system wide fullscreen animation. Setting anything higher than 500ms will only prematurely cancel the resize animation after the system wide animation ended. The upper limit is still set at 1000ms since it's possible that Apple or the user changes the system defaults. Anything higher than 1000ms though seems too long and shouldn't be set anyway. OS X and cocoa-cb only
--android-surface-size=<WxH>
Set dimensions of the rendering surface used by the Android gpu context. Needs to be set by the embedding application if the dimensions change during runtime (i.e. if the device is rotated), via the surfaceChanged callback.

Android with --gpu-context=android only.

--swapchain-depth=<N>
Allow up to N in-flight frames. This essentially controls the frame latency. Increasing the swapchain depth can improve pipelining and prevent missed vsyncs, but increases visible latency. This option only mandates an upper limit, the implementation can use a lower latency than requested internally. A setting of 1 means that the VO will wait for every frame to become visible before starting to render the next frame. (Default: 3)
--gpu-sw
Continue even if a software renderer is detected.
--gpu-context=<sys>
The value auto (the default) selects the GPU context. You can also pass help to get a complete list of compiled in backends (sorted by autoprobe order).

auto
auto-select (default)
cocoa
Cocoa/OS X (deprecated, use --vo=opengl-cb instead)
win
Win32/WGL
winvk
VK_KHR_win32_surface
angle
Direct3D11 through the OpenGL ES translation layer ANGLE. This supports almost everything the win backend does (if the ANGLE build is new enough).
dxinterop (experimental)
Win32, using WGL for rendering and Direct3D 9Ex for presentation. Works on Nvidia and AMD. Newer Intel chips with the latest drivers may also work.
d3d11
Win32, with native Direct3D 11 rendering.
x11
X11/GLX
x11vk
VK_KHR_xlib_surface
x11probe
For internal autoprobing, equivalent to x11 otherwise. Don't use directly, it could be removed without warning as autoprobing is changed.
wayland
Wayland/EGL
waylandvk
VK_KHR_wayland_surface
drm
DRM/EGL
x11egl
X11/EGL
android
Android/EGL. Requires --wid be set to an android.view.Surface.
mali-fbdev
Direct fbdev/EGL support on some ARM/MALI devices.
vdpauglx
Use vdpau presentation with GLX as backing. Experimental use only. Using this will have no advantage (other than additional bugs or performance problems), and is for doing experiments only. Will not be used automatically.
--gpu-api=<type>
Controls which type of graphics APIs will be accepted:

auto
Use any available API (default)
opengl
Allow only OpenGL (requires OpenGL 2.1+ or GLES 2.0+)
vulkan
Allow only Vulkan (requires a valid/working --spirv-compiler)
d3d11
Allow only --gpu-context=d3d11
--opengl-es=<mode>
Controls which type of OpenGL context will be accepted:

auto
Allow all types of OpenGL (default)
yes
Only allow GLES
no
Only allow desktop/core GL
--opengl-restrict=<version>
Restricts all OpenGL versions above a certain version. Versions are encoded in hundreds, i.e. OpenGL 4.5 -> 450. As an example, --opengl-restrict=300 would restrict OpenGL 3.0 and higher, effectively only allowing 2.x contexts. Note that this only imposes a limit on context creation APIs, the actual OpenGL context may still have a higher OpenGL version. (Default: 0)
--fbo-format=<fmt>
Selects the internal format of textures used for FBOs. The format can influence performance and quality of the video output. fmt can be one of: rgb8, rgb10, rgb10_a2, rgb16, rgb16f, rgb32f, rgba12, rgba16, rgba16f, rgba16hf, rgba32f. Default: auto, which maps to rgba16 on desktop GL, and rgba16f or rgb10_a2 on GLES (e.g. ANGLE), unless GL_EXT_texture_norm16 is available.
--gamma-factor=<0.1..2.0>
Set an additional raw gamma factor (default: 1.0). If gamma is adjusted in other ways (like with the  --gamma option or key bindings and the gamma property), the value is multiplied with the other gamma value.

Recommended values based on the environmental brightness:

1.0
Pitch black or dimly lit room (default)
1.1
Moderately lit room, home
1.2
Brightly illuminated room, office
NOTE: This is based around the assumptions of typical movie content, which contains an implicit end-to-end of about 0.8 from scene to display. For bright environments it can be useful to cancel that out.

--gamma-auto
Automatically corrects the gamma value depending on ambient lighting conditions (adding a gamma boost for bright rooms).

With ambient illuminance of 16 lux, mpv will pick the 1.0 gamma value (no boost), and slightly increase the boost up until 1.2 for 256 lux.

NOTE: Only implemented on OS X.

--target-prim=<value>
Specifies the primaries of the display. Video colors will be adapted to this colorspace when ICC color management is not being used. Valid values are:

auto
Disable any adaptation, except for atypical color spaces. Specifically, wide/unusual gamuts get automatically adapted to BT.709, while standard gamut (i.e. BT.601 and BT.709) content is not touched. (default)
bt.470m
ITU-R BT.470 M
bt.601-525
ITU-R BT.601 (525-line SD systems, eg. NTSC), SMPTE 170M/240M
bt.601-625
ITU-R BT.601 (625-line SD systems, eg. PAL/SECAM), ITU-R BT.470 B/G
bt.709
ITU-R BT.709 (HD), IEC 61966-2-4 (sRGB), SMPTE RP177 Annex B
bt.2020
ITU-R BT.2020 (UHD)
apple
Apple RGB
adobe
Adobe RGB (1998)
prophoto
ProPhoto RGB (ROMM)
cie1931
CIE 1931 RGB (not to be confused with CIE XYZ)
dci-p3
DCI-P3 (Digital Cinema Colorspace), SMPTE RP431-2
v-gamut
Panasonic V-Gamut (VARICAM) primaries
s-gamut
Sony S-Gamut (S-Log) primaries
--target-trc=<value>
Specifies the transfer characteristics (gamma) of the display. Video colors will be adjusted to this curve when ICC color management is not being used. Valid values are:

auto
Disable any adaptation, except for atypical transfers. Specifically, HDR or linear light source material gets automatically converted to gamma 2.2, while SDR content is not touched. (default)
bt.1886
ITU-R BT.1886 curve (assuming infinite contrast)
srgb
IEC 61966-2-4 (sRGB)
linear
Linear light output
gamma1.8
Pure power curve (gamma 1.8), also used for Apple RGB
gamma2.2
Pure power curve (gamma 2.2)
gamma2.8
Pure power curve (gamma 2.8), also used for BT.470-BG
prophoto
ProPhoto RGB (ROMM)
pq
ITU-R BT.2100 PQ (Perceptual quantizer) curve, aka SMPTE ST2084
hlg
ITU-R BT.2100 HLG (Hybrid Log-gamma) curve, aka ARIB STD-B67
v-log
Panasonic V-Log (VARICAM) curve
s-log1
Sony S-Log1 curve
s-log2
Sony S-Log2 curve
Note

When using HDR output formats, mpv will encode to the specified curve but it will not set any HDMI flags or other signalling that might be required for the target device to correctly display the HDR signal. The user should independently guarantee this before using these signal formats for display.

--target-peak=<nits>
Specifies the measured peak brightness of the output display, in cd/m^2 (AKA nits). The interpretation of this brightness depends on the configured  --target-trc. In all cases, it imposes a limit on the signal values that will be sent to the display. If the source exceeds this brightness level, a tone mapping filter will be inserted. For HLG, it has the additional effect of parametrizing the inverse OOTF, in order to get colorimetrically consistent results with the mastering display. For SDR, or when using an ICC (profile (--icc-profile), setting this to a value above 100 essentially causes the display to be treated as if it were an HDR display in disguise. (See the note below)

By default, the chosen peak defaults to an appropriate value based on the TRC in use. For SDR curves, it defaults to 100. For HDR curves, it defaults to 100 * the transfer function's nominal peak.

Note

When using an SDR transfer function, this is normally not needed, and setting it may lead to very unexpected results. The one time it is useful is if you want to calibrate a HDR display using traditional transfer functions and calibration equipment. In such cases, you can set your HDR display to a high brightness such as 800 cd/m^2, and then calibrate it to a standard curve like gamma2.8. Setting this value to 800 would then instruct mpv to essentially treat it as an HDR display with the given peak. This may be a good alternative in environments where PQ or HLG input to the display is not possible, and makes it possible to use HDR displays with mpv regardless of operating system support for HDMI HDR metadata.

In such a configuration, we highly recommend setting --tone-mapping to mobius or even clip.

--tone-mapping=<value>
Specifies the algorithm used for tone-mapping images onto the target display. This is relevant for both HDR->SDR conversion as well as gamut reduction (e.g. playing back BT.2020 content on a standard gamut display). Valid values are:

clip
Hard-clip any out-of-range values. Use this when you care about perfect color accuracy for in-range values at the cost of completely distorting out-of-range values. Not generally recommended.
mobius
Generalization of Reinhard to a Möbius transform with linear section. Smoothly maps out-of-range values while retaining contrast and colors for in-range material as much as possible. Use this when you care about color accuracy more than detail preservation. This is somewhere in between clip and reinhard, depending on the value of  --tone-mapping-param.
reinhard
Reinhard tone mapping algorithm. Very simple continuous curve. Preserves overall image brightness but uses nonlinear contrast, which results in flattening of details and degradation in color accuracy.
hable
Similar to reinhard but preserves both dark and bright details better (slightly sigmoidal), at the cost of slightly darkening / desaturating everything. Developed by John Hable for use in video games. Use this when you care about detail preservation more than color/brightness accuracy. This is roughly equivalent to  --hdr-tone-mapping=reinhard --tone-mapping-param=0.24. If possible, you should also enable --hdr-compute-peak for the best results. (Default)
gamma
Fits a logarithmic transfer between the tone curves.
linear
Linearly stretches the entire reference gamut to (a linear multiple of) the display.
--tone-mapping-param=<value>
Set tone mapping parameters. Ignored if the tone mapping algorithm is not tunable. This affects the following tone mapping algorithms:

clip
Specifies an extra linear coefficient to multiply into the signal before clipping. Defaults to 1.0.
mobius
Specifies the transition point from linear to mobius transform. Every value below this point is guaranteed to be mapped 1:1. The higher the value, the more accurate the result will be, at the cost of losing bright details. Defaults to 0.3, which due to the steep initial slope still preserves in-range colors fairly accurately.
reinhard
Specifies the local contrast coefficient at the display peak. Defaults to 0.5, which means that in-gamut values will be about half as bright as when clipping.
gamma
Specifies the exponent of the function. Defaults to 1.8.
linear
Specifies the scale factor to use while stretching. Defaults to 1.0.
--hdr-compute-peak=<auto|yes|no>
Compute the HDR peak and frame average brightness per-frame instead of relying on tagged metadata. These values are averaged over local regions as well as over several frames to prevent the value from jittering around too much. This option basically gives you dynamic, per-scene tone mapping. Requires compute shaders, which is a fairly recent OpenGL feature, and will probably also perform horribly on some drivers, so enable at your own risk. The special value auto (default) will enable HDR peak computation automatically if compute shaders and SSBOs are supported.
--tone-mapping-desaturate=<value>
Apply desaturation for highlights. The parameter essentially controls the steepness of the desaturation curve. The higher the parameter, the more aggressively colors will be desaturated. This setting helps prevent unnaturally blown-out colors for super-highlights, by (smoothly) turning into white instead. This makes images feel more natural, at the cost of reducing information about out-of-range colors.

The default of 0.5 provides a good balance. This value is weaker than the ACES ODT curves' recommendation, but works better for most content in practice. A setting of 0.0 disables this option.

--gamut-warning
If enabled, mpv will mark all clipped/out-of-gamut pixels that exceed a given threshold (currently hard-coded to 101%). The affected pixels will be inverted to make them stand out. Note: This option applies after the effects of all of mpv's color space transformation / tone mapping options, so it's a good idea to combine this with --tone-mapping=clip and use  --target-prim to set the gamut to simulate. For example,  --target-prim=bt.709 would make mpv highlight all pixels that exceed the gamut of a standard gamut (sRGB) display. This option also does not work well with ICC profiles, since the 3DLUTs are always generated against the source color space and have chromatically-accurate clipping built in.
--use-embedded-icc-profile
Load the embedded ICC profile contained in media files such as PNG images. (Default: yes). Note that this option only works when also using a display ICC profile (--icc-profile or  --icc-profile-auto), and also requires LittleCMS 2 support.
--icc-profile=<file>
Load an ICC profile and use it to transform video RGB to screen output. Needs LittleCMS 2 support compiled in. This option overrides the  --target-prim, --target-trc and --icc-profile-auto options.
--icc-profile-auto
Automatically select the ICC display profile currently specified by the display settings of the operating system.

NOTE: On Windows, the default profile must be an ICC profile. WCS profiles are not supported.

Applications using libmpv with the render API need to provide the ICC profile via MPV_RENDER_PARAM_ICC_PROFILE.

--icc-cache-dir=<dirname>
Store and load the 3D LUTs created from the ICC profile in this directory. This can be used to speed up loading, since LittleCMS 2 can take a while to create a 3D LUT. Note that these files contain uncompressed LUTs. Their size depends on the --icc-3dlut-size, and can be very big.

NOTE: This is not cleaned automatically, so old, unused cache files may stick around indefinitely.

--icc-intent=<value>
Specifies the ICC intent used for the color transformation (when using  --icc-profile).

0
perceptual
1
relative colorimetric (default)
2
saturation
3
absolute colorimetric
--icc-3dlut-size=<r>x<g>x<b>
Size of the 3D LUT generated from the ICC profile in each dimension. Default is 64x64x64. Sizes may range from 2 to 512.
--icc-contrast=<0-1000000>
Specifies an upper limit on the target device's contrast ratio. This is detected automatically from the profile if possible, but for some profiles it might be missing, causing the contrast to be assumed as infinite. As a result, video may appear darker than intended. This only affects BT.1886 content. The default of 0 means no limit.
--blend-subtitles=<yes|video|no>
Blend subtitles directly onto upscaled video frames, before interpolation and/or color management (default: no). Enabling this causes subtitles to be affected by --icc-profile, --target-prim,  --target-trc,  --interpolation, --gamma-factor and --glsl-shaders. It also increases subtitle performance when using --interpolation.

The downside of enabling this is that it restricts subtitles to the visible portion of the video, so you can't have subtitles exist in the black margins below a video (for example).

If video is selected, the behavior is similar to yes, but subs are drawn at the video's native resolution, and scaled along with the video.

Warning

This changes the way subtitle colors are handled. Normally, subtitle colors are assumed to be in sRGB and color managed as such. Enabling this makes them treated as being in the video's color space instead. This is good if you want things like softsubbed ASS signs to match the video colors, but may cause SRT subtitles or similar to look slightly off.

--alpha=<blend-tiles|blend|yes|no>
Decides what to do if the input has an alpha component.

blend-tiles
Blend the frame against a 16x16 gray/white tiles background (default).
blend
Blend the frame against the background color (--background, normally black).
yes
Try to create a framebuffer with alpha component. This only makes sense if the video contains alpha information (which is extremely rare). May not be supported on all platforms. If alpha framebuffers are unavailable, it silently falls back on a normal framebuffer. Note that if you set the --fbo-format option to a non-default value, a format with alpha must be specified, or this won't work. This does not work on X11 with EGL and Mesa (freedesktop bug 67676).
no
Ignore alpha component.
--opengl-rectangle-textures
Force use of rectangle textures (default: no). Normally this shouldn't have any advantages over normal textures. Note that hardware decoding overrides this flag. Could be removed any time.
--background=<color>
Color used to draw parts of the mpv window not covered by video. See  --osd-color option how colors are defined.
--gpu-tex-pad-x, --gpu-tex-pad-y
Enlarge the video source textures by this many pixels. For debugging only (normally textures are sized exactly, but due to hardware decoding interop we may have to deal with additional padding, which can be tested with these options). Could be removed any time.
--opengl-early-flush=<yes|no|auto>
Call glFlush() after rendering a frame and before attempting to display it (default: auto). Can fix stuttering in some cases, in other cases probably causes it. The auto mode will call glFlush() only if the renderer is going to wait for a while after rendering, instead of flipping GL front and backbuffers immediately (i.e. it doesn't call it in display-sync mode).

On OSX this is always deactivated because it only causes performance problems and other regressions.

--gpu-dumb-mode=<yes|no|auto>
This mode is extremely restricted, and will disable most extended features. That includes high quality scalers and custom shaders!

It is intended for hardware that does not support FBOs (including GLES, which supports it insufficiently), or to get some more performance out of bad or old hardware.

This mode is forced automatically if needed, and this option is mostly useful for debugging. The default of auto will enable it automatically if nothing uses features which require FBOs.

This option might be silently removed in the future.

--gpu-shader-cache-dir=<dirname>
Store and load compiled GLSL shaders in this directory. Normally, shader compilation is very fast, so this is usually not needed. It mostly matters for GPU APIs that require internally recompiling shaders to other languages, for example anything based on ANGLE or Vulkan. Enabling this can improve startup performance on these platforms.

NOTE: This is not cleaned automatically, so old, unused cache files may stick around indefinitely.


autospeed-nircmd=false
    true/false - Use nircmd to change the refresh rate of your monitor.
    nircmd will be used to change the refresh rate of your monitor based on options listed below.
autospeed-speed=false
    Default: false
    true/false - Adjust speed of the video?
    If set to true, the mpv speed setting will be changed based on the video
    fps and display refresh rate.
    Do not use this with mpv's --video-sync=display-resample
autospeed-nircmdc="nircmdc"
    String - Path to nircmdc executable file.
    If not set, nircmdc will be searched in Windows PATH variable.
    If you set this "" or "nircmdc", Windows will look in your PATH for nircmdc,
    otherwise you can specify a path, for example "c:\programs\nircmdc.exe"
autospeed-monitor=0
    Number - Which monitor (display) to set the refresh rate on.
    This will be sent to nircmd when setting the refresh rate.
autospeed-dwidth=1920
    Number - Display width.
    This will be sent to nircmd when setting the refresh rate.
autospeed-dheight=1080
    Number - Display height.
    This will be sent to nircmd when setting the refresh rate.
autospeed-bdepth=32
    Number - Display bit depth. 32 is usually the default.
    This will be sent to nircmd when setting the refresh rate.
autospeed-rates="60"
    String - String of refresh rates your monitor supports and you want
        to use, separated by semicolons. Nircmd seems to prefer rounded
        numbers, 72 instead of 71.92 for example.
    This is the list of refresh rates you want autospeed to use when it changes your monitor refresh rate.
    Examples: autospeed-rates="60" | autospeed-rates="50;60;72"
    Note: If you want a rate to be prefered over another, for example the video is 24hz
    and your rates are "100;120;144", but you want 144hz instead of 120hz for 24fps videos, change the
    order to autospeed-rates="100;144;120", then 144hz will take precendence over 120hz.
autospeed-exitrate=60
    Number - Which refresh rate to set when exiting mpv. Set to 0 to ignore.
    When mpv exits, if you want your monitor to go back to a specific refresh rate.
autospeed-minspeed=0.9
    Number - Minimum allowable speed to play video at.
    Does not change mpv's speed setting if the calculated speed is lower than this.
    This is to prevent the video looking like it is in slow motion.
    A value of 0.9 allows playing the video at minimum, 10% slower.
autospeed-maxspeed=1.1
    Number - Maximum allowable speed to play video at.
    Does not change mpv's speed setting if the calculated speed is higher than this.
    This is to prevent the video looking like it is in fast forward.
    A value of 1.1 allows playing the video at maximum, 10% faster.
autospeed-osd=false
    true/false - Enable OSD.
    This enables/disables the other autospeed-osd settings.
autospeed-osdtime=10
    Number - How many seconds the OSD will be shown.
autospeed-osdkey=y
    Key to press to show the OSD.
    This follows the same standard as mpv's input.conf for keybindgs.
    Pressing this key will display autospeed information on mpv's OSD.
autospeed-estfps=false
    true/false - Calculate/change speed if a video has a variable fps
                 at the cost of higher CPU usage.
    If a video has a variable frame rate (fps),
    calculate / set the mpv speed based on the current video frame rate.
    This option will do nothing for most videos because, only few of them have variable fps.
    For example, most (all?) bluray videos have variable frame rates.
    Since the speed calulation must be done every time the video fps changes,
    this increases CPU load slightly.
autospeed-spause=4
    Default: false
    true/false - Pause video while switching display modes.
                 true:  This will pause the video before and after switching the mode.
                 false: Disables this option.
    Number     - This enables the pause like true and sleeps for this amount of seconds.
                 If bigger than 0: After switching the mode, we will wait this amount
                 of seconds before unpausing the video.
                 If set to 0:      It disables the option, like false.
    Before switching the display mode (refresh rate), pause the video, unpause after
    it is switched. This can be used if you don't want to miss
    some of the video while your display is blank (my display is blank for ~5 seconds
    while switching modes).

Examples:
    Setting the options at the command line:
        mpv file.mkv --script-opts=autospeed-speed=true,autospeed-estfps=true,autospeed-minspeed=0.8
    Setting the options in %APPDATA%\mpv\mpv.conf:
        script-opts=autospeed-nircmd=true,autospeed-speed=false,autospeed-nircmdc="nircmdc",autospeed-monitor=0,autospeed-dwidth=1920,autospeed-dheight=1080,autospeed-bdepth=32,autospeed-rates="60;72",autospeed-exitrate=60,autospeed-minspeed=0.9,autospeed-maxspeed=1.1,autospeed-osd=true,autospeed-osdtime=10,autospeed-osdkey=y,autospeed-estfps=false,autospeed-spause=4

